package com.example.chaterv3;import androidx.appcompat.app.ActionBar;import androidx.appcompat.app.AlertDialog;import androidx.appcompat.app.AppCompatActivity;import androidx.core.app.NavUtils;import androidx.recyclerview.widget.LinearLayoutManager;import androidx.recyclerview.widget.RecyclerView;import android.app.Dialog;import android.content.Context;import android.content.DialogInterface;import android.content.Intent;import android.graphics.Color;import android.graphics.Typeface;import android.graphics.drawable.ColorDrawable;import android.graphics.drawable.TransitionDrawable;import android.os.Bundle;import android.os.Handler;import android.text.Spannable;import android.text.SpannableStringBuilder;import android.text.style.ForegroundColorSpan;import android.text.style.StyleSpan;import android.view.Gravity;import android.view.KeyEvent;import android.view.LayoutInflater;import android.view.Menu;import android.view.MenuItem;import android.view.View;import android.view.ViewGroup;import android.view.Window;import android.view.WindowManager;import android.widget.Button;import android.widget.EditText;import android.widget.TextView;import android.widget.Toast;import java.util.Date;import java.util.HashMap;import java.util.LinkedList;class Message {    private String text, senderLocalName;    private boolean isMine, displayMinimal = false, edited = false, isReplying = false;    private long sendTime, id;    private Message replyFor;    public static long maxMsgDeltaTime = 300; // 5 minut    public Message(long id, String text, boolean isMine, long sendTime, String senderLocalName, boolean edited, Message replyFor){        if(replyFor != null) {            this.replyFor   = replyFor;            this.isReplying = true;        }        this.edited          = edited;        this.id              = id;        this.senderLocalName = senderLocalName;        this.sendTime        = sendTime;        this.text            = text;        this.isMine          = isMine;    }    public void deleteReply()                               { isReplying =false;replyFor=null;}    public void setReply(Message replyId)                   { isReplying = true;replyFor = replyId;}    public boolean isReplying()                             { return isReplying;};    public Message getReply()                               { return replyFor;};    public boolean isEdited()                               { return edited; }    public void setEdited(boolean edited)                   { this.edited = edited;}    public long getId()                                     { return id;}    public void setId(long id)                              { this.id = id;}    public String getSenderLocalName()                      { return senderLocalName;}    public void setSenderLocalName(String senderLocalName)  { this.senderLocalName = senderLocalName; }    public long getSendTime()                               { return sendTime;}    public void setSendTime(long sendTime)                  { this.sendTime = sendTime;}    public boolean isDisplayMinimal()                       { return displayMinimal;}    public void setDisplayMinimal(boolean displayMinimal)   { this.displayMinimal = displayMinimal;}    public String getText()                                 { return this.text;}    public void setText(String text)                        { this.text = text;}    public boolean isMine()                                 { return this.isMine;}    public void setWhose(boolean isMine)                    { this.isMine = isMine;}}class StateAdapter extends RecyclerView.Adapter<StateAdapter.MessageHolder>{    private final LayoutInflater inflater;    private final Context context;    private final RecyclerView recyclerView;    private final LinkedList<Message> messages;    private final chat me;    private static int MESSAGE_MINE = 1;    private static int MESSAGE_OTHER = 2;    private static int MESSAGE_OTHER_ADDICTION = 3;    private static int MESSAGE_OTHER_ADDICTION_NOSENDER = 5;    private static int MESSAGE_MINE_ADDICTION = 4;    StateAdapter(chat me, RecyclerView rec, Context context, LinkedList<Message> msgs) {        this.messages = msgs;        this.inflater = LayoutInflater.from(context);        this.context  = context;        this.me       = me;        recyclerView  = rec;    }    @Override    public StateAdapter.MessageHolder onCreateViewHolder(ViewGroup parent, int viewType) {        int layout = R.layout.msg;        switch (viewType){            case 1:case 4:                layout = R.layout.mymsg;                break;            case 2:case 3: case 5:                layout = R.layout.othermsg;                break;        }        final View view = inflater.inflate(layout, parent, false);        view.findViewById(R.id.reply).setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View vieww) {                final int itemPosition = recyclerView.getChildLayoutPosition(view);                final Message reply = messages.get(itemPosition).getReply();                if (reply != null) {                    try {                        final int[] i = {0};                        for (Message message : messages) {                            if (message.getId() == reply.getId()) {                                recyclerView.scrollToPosition(i[0]);                                break;                            }                            i[0]++;                        }                        if(i[0] == messages.size()){                            Helpful.toast(me, "Вложенное сообщение не загружено");                        }                    } catch (Exception e) {                        Helpful.toast(me, "error: " + e.getMessage());                    }                }            }        });        view.setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View view) {                final int itemPosition = recyclerView.getChildLayoutPosition(view);                final Message item = messages.get(itemPosition);                AlertDialog.Builder builder1 = new AlertDialog.Builder(context);                builder1.setTitle("Сообщение от " + item.getSenderLocalName());                String[] actions = {"Ответить", "Переслать(не раб.)", "Удалить"};                String[] myActions = {actions[0], actions[1], "Удалить", "Редактировать"};                builder1.setItems(item.isMine() ? myActions : actions, new DialogInterface.OnClickListener() {                    @Override                    public void onClick(DialogInterface dialogInterface, int which) {                        String usedMethod = null;                        HttpManager.resultActionHolder holder = null;                        switch(which){                            case 0: //REPLY                                me.isReplying = true;                                me.replyMsg = item;                                me.updateInterface();                                break;                            case 2: //DELETE                                usedMethod = "message.delete";                                holder = new HttpManager.resultActionHolder() {                                    @Override                                    public void run(final String result) {                                        me.runOnUiThread(new Runnable() {                                            @Override                                            public void run() {                                                messages.remove(itemPosition);                                                notifyDataSetChanged();                                            }                                        });                                    }                                };                                break;                            case 3: //EDIT                                me.isEditing = true;                                me.editMsgId = item.getId();                                EditText msg = (EditText) me.findViewById(R.id.message);                                msg.requestFocus();                                msg.setText(item.getText());                                msg.setSelection(item.getText().length());                                me.updateInterface();                            break;                        }                        if(usedMethod == null) return;                        HashMap<String, String> params = new HashMap<>();                        params.put("chat", String.valueOf(chat.chatId));                        params.put("id", String.valueOf(item.getId()));                        HttpManager.callToApiNewThread(usedMethod, params, holder, me);                    }                });                Dialog dlg = builder1.create();                Window window = dlg.getWindow();                WindowManager.LayoutParams wlp = window.getAttributes();                window.getAttributes().windowAnimations = R.style.DialogAnimation;                wlp.gravity = Gravity.BOTTOM;                wlp.flags &= ~WindowManager.LayoutParams.FLAG_DIM_BEHIND;                window.setAttributes(wlp);                dlg.show();            }        });        return new MessageHolder(view, viewType);    }    @Override    public void onBindViewHolder(StateAdapter.MessageHolder holder, int position) {        Message state = messages.get(position);        if (state.isEdited()) {            final SpannableStringBuilder sb = new SpannableStringBuilder(state.getText() + " (ред.)");            final ForegroundColorSpan fcs = new ForegroundColorSpan(Color.rgb(211, 211, 211));            final StyleSpan bss = new StyleSpan(Typeface.ITALIC);            sb.setSpan(fcs, state.getText().length(), state.getText().length() + 7, Spannable.SPAN_INCLUSIVE_INCLUSIVE);            sb.setSpan(bss, state.getText().length(), state.getText().length() + 7, Spannable.SPAN_INCLUSIVE_INCLUSIVE);            holder.textView.setText(sb);        } else {            holder.textView.setText(state.getText());        }        if (!(holder.viewType == MESSAGE_MINE_ADDICTION || holder.viewType == MESSAGE_OTHER_ADDICTION )) {            long seconds = (state.getSendTime());            Date date = new Date(seconds * 1000);            int hrs = date.getHours();            int mins = date.getMinutes();            boolean addZeroH = (hrs < 10), addZeroM = (mins < 10);            holder.time.setText((addZeroH ? "0" : "") + hrs + ":" + (addZeroM ? "0" : "") + mins);            if(holder.viewType != MESSAGE_OTHER_ADDICTION_NOSENDER) {                holder.sender.setText(state.getSenderLocalName());            }else{                holder.sender.setVisibility(View.GONE);            }        } else{            holder.time.setVisibility(View.GONE);            holder.sender.setVisibility(View.GONE);        }        if(!state.isReplying()){            holder.reply.setVisibility(View.GONE);        }else{            holder.reply.setVisibility(View.VISIBLE);            holder.replySender.setText(state.getReply().getSenderLocalName());            holder.replyText.setText(state.getReply().getText());        }    }    @Override    public int getItemViewType(int position) {        if(position > 0) {            if (!messages.get(position - 1).isMine() && !messages.get(position).isMine() && messages.get(position-1).getSenderLocalName().equalsIgnoreCase(messages.get(position).getSenderLocalName())){                if(messages.get(position).getSendTime() - messages.get(position-1).getSendTime() >= Message.maxMsgDeltaTime){                    return MESSAGE_OTHER_ADDICTION_NOSENDER;                }else{                    return MESSAGE_OTHER_ADDICTION;                }            }            if(messages.get(position - 1).isMine() && messages.get(position).isMine()){                if(messages.get(position).getSendTime() - messages.get(position-1).getSendTime() >= Message.maxMsgDeltaTime){                    return MESSAGE_MINE;                }                return MESSAGE_MINE_ADDICTION;            }        }        if(messages.get(position).isMine()){            return MESSAGE_MINE;        }        return MESSAGE_OTHER;    }    @Override    public int getItemCount() {        return messages.size();    }    public static class MessageHolder extends RecyclerView.ViewHolder {        final TextView textView, sender, time, replySender, replyText;        final View reply;        final int viewType;        MessageHolder(View view, int viewType1){            super(view);            viewType = viewType1;            textView = (TextView) view.findViewById(R.id.text);            sender = (TextView) view.findViewById(R.id.sender);            time = (TextView) view.findViewById(R.id.timedate);            replySender = (TextView) view.findViewById(R.id.replySender);            replyText = (TextView) view.findViewById(R.id.replyText);            reply = view.findViewById(R.id.reply);        }    }}public class chat extends AppCompatActivity {    public static long chatId = -1;    private static String chatName = "Ты не должен это видеть", chatDescription = "Чат";    public boolean isEditing = false;    public long editMsgId = 0;    public boolean isReplying = false;    public Message replyMsg = null;    public static int msgLoadCount = 20;    public long loadedMsgs = 0;    private boolean inFocus;    public RecyclerView recView;    public LinkedList<Message> messages = new LinkedList<Message>();    public void updateInterface(){        if(!isEditing){            ActionBar ab = getSupportActionBar();            ab.setTitle(chatName);            ab.setSubtitle(chatDescription);            ab.setHomeAsUpIndicator(0);            invalidateOptionsMenu();            ((Button) findViewById(R.id.sendmsg)).setText("отправить");            ((EditText)findViewById(R.id.message)).setText("");        }else{            ActionBar ab = getSupportActionBar();            ab.setTitle("Редактирование сообщения");            ab.setHomeAsUpIndicator(android.R.drawable.ic_menu_close_clear_cancel);            ab.setSubtitle("");            ((Button) findViewById(R.id.sendmsg)).setText("готово");        }        View replyInd = findViewById(R.id.replyindicator);        if (isReplying) {            ((TextView)replyInd.findViewById(R.id.replySender)).setText(replyMsg.getSenderLocalName());            ((TextView)replyInd.findViewById(R.id.replyText)).setText(replyMsg.getText());            replyInd.setVisibility(View.VISIBLE);        }else{            replyInd.setVisibility(View.GONE);        }        invalidateOptionsMenu();    }    public int dpToPx(int dp) {        float density = getApplicationContext().getResources()                .getDisplayMetrics()                .density;        return Math.round((float) dp * density);    }    private void validateMessages(){        boolean disableNext = false;        for (int i = 0; i < messages.size()-1; i++) { // i+1 is always exists            if(!messages.get(i).isMine()) messages.get(i).setDisplayMinimal(disableNext);            disableNext = false;            if(!messages.get(i+1).isMine() && !messages.get(i).isMine()){                disableNext = true;            }        }        if(!messages.get(messages.size()-1).isMine()) messages.get(messages.size()-1).setDisplayMinimal(disableNext);    }    public void updateDisplayNoScroll() {        recView.getAdapter().notifyDataSetChanged();    }    public void updateDisplay(int itemToScroll) { // -1 == adapter.getItemCount()-1        StateAdapter adapter = new StateAdapter(this, recView, this, messages); //я не знаю почему, но если делать не так он  просто скроллит до позиции так, чтобы она была внизу, а так не надо        recView.setAdapter(adapter);        if(itemToScroll == -100) return;        if (itemToScroll == -1 && adapter.getItemCount() > 0) {            itemToScroll =  adapter.getItemCount() - 1;        }        if (itemToScroll != 0) {            recView.scrollToPosition(itemToScroll);        }    }    @Override    public boolean onCreateOptionsMenu(Menu menu) {        getMenuInflater().inflate(R.menu.chatmenu, menu);        menu.findItem(R.id.chatinfo).setVisible(!isEditing);        return true;    }    @Override    public boolean onOptionsItemSelected(MenuItem item) {        switch (item.getItemId()) {            case android.R.id.home:                if(isEditing){                    isEditing=false;                    updateInterface();                }else {                    finish();                }                return true;            case R.id.chatinfo:                Intent intent = new Intent(chat.this, ChatInfo.class);                intent.putExtra("chatId", chatId);                startActivity(intent);                return true;            default:                return super.onOptionsItemSelected(item);        }    }    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_chat);        // -------------------------- INIT START ---------------------------------        ActionBar ab = getSupportActionBar();        ab.setDisplayHomeAsUpEnabled(true);        ab.setTitle(chatName);        ab.setSubtitle(chatDescription);        if(chatId == -1 || !LoginSystem.hasInternetConnection()){            Toast.makeText(this, "Нет подключения к сети", Toast.LENGTH_SHORT).show();            finish();            return;        }        final chat me = this;        final EditText message = ((EditText) findViewById(R.id.message));        final Button sendmsg = (Button) findViewById(R.id.sendmsg);        final Handler handler = new Handler();        recView = findViewById(R.id.main);        recView.setLayoutManager(new LinearLayoutManager(this));        StateAdapter adapter = new StateAdapter(this, recView, this, messages);        recView.setAdapter(adapter);        recView.addOnLayoutChangeListener(new View.OnLayoutChangeListener() {            @Override            public void onLayoutChange(View view, int i, int i1, int i2, int bottom, int i4, int i5, int i6, int oldBottom) {                if ( bottom < oldBottom) {                    recView.postDelayed(new Runnable() {                        @Override                        public void run() {                            if(messages.size() != 0) recView.smoothScrollToPosition(messages.size()-1);                        }                    }, 100);                }            }        });        final MessageUtils msgController = new MessageUtils();        sendmsg.setOnClickListener(                new View.OnClickListener() {                    @Override                    public void onClick(View view) {                        if(isEditing) {                            msgController.editMsg(me, editMsgId, message.getText().toString(), replyMsg);                            isEditing = false;                        }else{                            msgController.sendMsg(me, message.getText().toString(), replyMsg);                        }                        isReplying = false;                        replyMsg = null;                        updateInterface();                        message.setText("");                    }                }        );        message.setOnKeyListener(new View.OnKeyListener() {            public boolean onKey(View v, int keyCode, KeyEvent event) {                if ((event.getAction() == KeyEvent.ACTION_DOWN) && (keyCode == KeyEvent.KEYCODE_ENTER)) {                    if(isEditing) {                        msgController.editMsg(me, editMsgId, message.getText().toString(), replyMsg);                        isEditing = false;                    }else{                        msgController.sendMsg(me, message.getText().toString(), replyMsg);                    }                    isReplying = false;                    replyMsg = null;                    updateInterface();                    message.setText("");                    return true;                }                return false;            }        });        findViewById(R.id.cancelReply).setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View view) {                isReplying = false;                replyMsg = null;                updateInterface();            }        });        recView.addOnScrollListener(new RecyclerView.OnScrollListener() {            @Override            public void onScrollStateChanged(RecyclerView recyclerView, int newState) {                super.onScrollStateChanged(recyclerView, newState);            }            @Override            public void onScrolled(RecyclerView recyclerView, int dx, int dy) {                super.onScrolled(recyclerView, dx, dy);                if(recView.computeVerticalScrollOffset() == 0){                    msgController.getPart(me);                }            }        });        // -------------------------- INIT END ---------------------------------        msgController.getLast(me);        //ЧЕК ПУК НОВЫХ СООБЩЕНИЙ        new Runnable() {            public void run() {                if(LoginSystem.hasInternetConnection() && inFocus){                    msgController.getNews(me);                }                handler.postDelayed(this, 2000);            }        }.run();    }    @Override    protected void onStop() {        super.onStop();        inFocus = false;    }    @Override    protected void onStart() {        super.onStart();        inFocus = true;        recView.getAdapter().notifyDataSetChanged();    }    public static void setChat(ChatContainer chat){        chatId   = chat.getChatId();        chatName = chat.getChatname();    }}